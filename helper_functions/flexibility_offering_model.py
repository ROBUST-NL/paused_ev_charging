# -*- coding: utf-8 -*-
"""
Created on Wed Dec 20 13:51:22 2023

@author: 4013425
"""

"""
 -*- coding: utf-8 -*-
@Time : 23/02/22 2:59 PM
@Author : nkpanda
@FileName: models.py
@Git ï¼šhttps://github.com/nkpanda97
"""


import numpy as np
from pyomo.environ import *
from pyomo.environ import \
    units as u  # Used for unit consistence, dependecies==pint


def update_model_cl(model,
                 ev_data,
                 dumb_profile,
                 flex_time_start,
                 flex_time_end,
                 pmin_tag='',sampled_date='',increment=0,
                 keywords=None):
    """
    This function updates the parameters of the model based on the input data.
    :param model: Concrete model
    :type model: pyomo.core.base.PyomoModel.ConcreteModel
    :param ev_data: DataFrame containing EV transaction details. The dataframe must contain
                    the following features:
                        * Information about arrival time (value should be an integer)
                        * Information about departure time (value should be an integer)
                        * Information about total available duration (value should be an integer)
                        * Information about total volume of energyrequired for charging (value should be in kWh)
                        * Information about maximum rate of charging (value should be in kW)
    :type ev_data: pandas.DataFrame
    :param dumb_profile: The aggregate profile for the set of EVs in the ev_data which is generated by the function
        generate_dumb_charging_profile(). The profile is generated by not taking into acount any omptimization.
    :type dumb_profile: numpy.array
    :param flex_time_start: The start time (in number of time-steps) from which the flexibility is needed.
    :type flex_time_start: int
    :param flex_time_end: The end time (in number of time-steps) till which the flexibility is needed.
    :type flex_time_end: int
    :param bi_directional_charging: Boolean value to indicate if the EVs are bi-directional or not.
    :type bi_directional_charging: bool
    :return: This function returns the unsolved concrete model with updated parameters.
    :rtype: pyomo.core.base.PyomoModel.ConcreteModel
    """
    if keywords is None:
        keywords = {'arrival_time': 'START_int',
                    'departure_time': 'STOP_int_adjusted',
                    'energy_charged': 'VOL_adj',
                    'max_charging_power': 'P_MAX'}

    model.flex_start = flex_time_start
    model.flex_end = flex_time_end
    
   
    for n in model.N:
        model.vol_ev[n] = ev_data[keywords['energy_charged']].iloc[n]
        if ev_data['START'].iloc[n].date() == sampled_date.date():
            model.t_a_ev[n] = ev_data[keywords['arrival_time']].iloc[n]+ increment
            model.t_d_ev[n] = ev_data[keywords['departure_time']].iloc[n]+ increment
        else:
            model.t_a_ev[n] = ev_data[keywords['arrival_time']].iloc[n]-increment
            model.t_d_ev[n] = ev_data[keywords['departure_time']].iloc[n] - increment
        model.p_max_ev[n] = ev_data[keywords['max_charging_power']].iloc[n]
        if ev_data[keywords['max_charging_power']].iloc[n] < ev_data[pmin_tag].iloc[n]:
            model.p_min_ev[n] = ev_data[keywords['max_charging_power']].iloc[n]
        else:
            model.p_min_ev[n] = ev_data[pmin_tag].iloc[n]
        
    for t in model.T:
        model.base_profile[t] = dumb_profile[t]


def ev_charging_model(ev_data,
                      dumb_profile,
                      t_step_size=0.25,
                      time_horizon=36 * 4,
                      flex_time_start=17 * 4,
                      flex_time_end=22 * 4, lambda_value=0.0001,
                      bi_directional_charging_value=False,
                      keywords_=None):
    """This function creates a Linear optimisation (concrete) model for smart EV charging based on the following
        strategies:
        * Re-dispatch: Based on the proper selection of constraints and objective function, the model can be used to
                        re-dispatch the EVs to a new charging profile by minimising the aggregated demand based on BAU profile.
                        The BAU profile is based on dumb charging of EVs.
        * Capacity limitation: Based on the proper selection of constraints and objective function, the model can be used to
                            limit the total charging demand of EVs to a certain value.

        * Greedy dispatch: In this mode the algorithms greedily dispatches the EVs so that the demand is minimised
                            between the flex request windows.

    :param keywords_:
    :type keywords_:
    :param ev_data: DataFrame containing EV transaction details. The dataframe must contain
                    the following features:
                    * Information about arrival time (value should be an integer)
                    * Information about departure time (value should be an integer)
                    * Information about total available duration (value should be an integer)
                    * Information about total volume of energyrequired for charging (value should be in kWh)
                    * Information about maximum rate of charging (value should be in kW)
    :type ev_data: pandas.DataFrame
    :param dumb_profile: The aggregate profile for the set of EVs in the ev_data which is generated by the function
        generate_dumb_charging_profile(). The profile is generated by not taking into acount any omptimization.
    :type dumb_profile: numpy.array
    :param t_step_size: The step size of each optimisation period (in hours)
    :type t_step_size: float
    :param time_horizon: The total time horizon for which the system is optimized
    :type time_horizon: int
    :param flex_time_start: The start time (in number of time-steps) from which the flexibility is needed.
    :type flex_time_start: int
    :param flex_time_end: The end time (in number of time-steps) till which the flexibility is needed.
    :type flex_time_end: int
    :param bi_directional_charging_value: Boolean value to indicate if the EVs are bi-directional or not.
    :type bi_directional_charging_value: bool
    :param lambda_value: Sensitivity parameter for the objective function.
    :type lambda_value: float
    :return: This function returns the unsolved concrete model with updated parameters.
    :rtype: pyomo.core.base.PyomoModel.ConcreteModel
    """
    Set_T_length = time_horizon
    Set_N_length = len(ev_data)
    # ---------------------------------- Creating empty model ----------------------------------
    model = ConcreteModel()
    # print('## A concrete optimization model is created for a total %.2f time steps' % Set_T_length)
    # -------------------------------------- Creating Sets --------------------------------------
    model.N = Set(ordered=True, initialize=np.arange(Set_N_length))
    model.T = Set(ordered=True, initialize=np.arange(Set_T_length))

    # ---------------------------------- Creating parameters ----------------------------------
    model.vol_ev = Param(model.N, within=NonNegativeReals, mutable=True, units=u.kWh,
                         doc='Assumed maximum volume of charge in '
                             'kWh that a vehicle can take or is allowed to '
                             'give')
    model.t_a_ev = Param(model.N, within=NonNegativeIntegers, mutable=True, doc='Time step from which a vheicle '
                                                                                'is available')
    model.t_d_ev = Param(model.N, within=NonNegativeIntegers, mutable=True, doc='Time step till which a '
                                                                                'vheicle is still '
                                                                                'available available')
    model.p_max_ev = Param(model.N, within=NonNegativeReals, mutable=True, units=u.kW, doc='Constraint on max power '
                                                                                           'value at which a vheicle can charge it')
    model.p_min_ev = Param(model.N, within=Reals, mutable=True, units=u.kW, doc='Constraint on min '
                                                                                           'power value '
                                                                                           'at which a vheicle can charge '
                                                                                           'it')
    model.base_profile = Param(model.T, mutable=True, doc='Aggregated profile of EVs as per dumb charging')
    model.step_size = Param(initialize=t_step_size, mutable=True, doc='Step size of analysis in hours')
    model.flex_start = Param(initialize=flex_time_start, mutable=True, doc='Initeeger timestep from which'
                                                                           ' flexibility is required')
    model.flex_end = Param(initialize=flex_time_end, mutable=True, doc='Initeger timestep till which'
                                                                       ' flexibility is required')
    model.lambda_ = Param(initialize=lambda_value, mutable=False,
                          doc='Sensitivity parameter for the objective function')

    # ---------------------------------- Creating Variables----------------------------------
    model.p_ch_ev = Var(model.T, model.N, within=Reals, units=u.kW,
                        doc='A NonNegativeReals variable denoting the '
                            'charging power of nth EV at time t')
    model.soe_ev = Var(model.T, model.N, within=NonNegativeReals, units=u.kWh,
                       doc='A NonNegativeReals variable denoting the state '
                           'of charge of nth EV at time t')
    model.aux_var = Var(within=NonNegativeReals, doc='Auxiliary variable used for objective function')

    model.aux_var_greedy = Var(model.N, within=Reals, doc='Auxiliary variable used for '  #TODO: check the domain
                                                                     'objective function for greedy algorithm')

    # ---------------------------------- Update parameters ----------------------------------
    update_model(model, ev_data, dumb_profile, flex_time_start, flex_time_end,
                 bi_directional_charging=bi_directional_charging_value,
                 keywords=keywords_)

    # ------------------------- Constraint Functions -----------------------------------------
    def charging_power_limits(model_, t, n):
        """
        Constraint rule to enforce limits on the charging power limits
        """
        if (t >= model_.t_a_ev[n].value) & (t < model_.t_d_ev[n].value):
            return model_.p_min_ev[n], model_.p_ch_ev[t, n], model_.p_max_ev[n]
        else:
            return model_.p_ch_ev[t, n] == 0

    def final_soe(model_, t, n):
        """
        This constraint rule makes sure that all  the EVs are charged by the time they depart from the charger.
        """
        if t >= model_.t_d_ev[n].value:
            return model_.soe_ev[t, n] == model_.vol_ev[n]
        else:
            return model_.soe_ev[t, n] <= model_.vol_ev[n]

    def soe_update(model_, t, n):
        """
        This constraint updates the state of energy of the EVs based omn previous state and next step charging power.
        """
        if t <= model_.t_a_ev[n].value:
            return model_.soe_ev[t, n] == 0
        else:
            return model_.soe_ev[t, n] == model_.soe_ev[model_.T.prev(t), n] + \
                model_.step_size * (model_.p_ch_ev[model_.T.prev(t), n])

    def re_dispatch(model_, t):
        """
        Constraint rule for auxiliary variable used in objective function for re-dispatch (eq 1f)

        """
        if (t >= model_.flex_start.value) & (t <= model_.flex_end.value):
            return sum(model_.p_ch_ev[t, n] for n in model_.N) <= model_.base_profile[t] - model_.aux_var
        else:
            return Constraint.Skip

    def capacity_limitation(model_, t):
        """
        Constraint rule for auxiliary variable used in objective function for capacity limitation (eq 2f)

        """
        if (t >= model_.flex_start.value) & (t <= model_.flex_end.value):
            return sum(model_.p_ch_ev[t, n] for n in model_.N) <= model_.aux_var
        else:
            return Constraint.Skip

    def greedy_dispatch(model_, t, n):
        """
        Constraint rule for auxiliary variable used in objective function for greedy dispatch (eq 3f)

        """
        if (t >= model_.flex_start.value) & (t <= model_.flex_end.value):
            return model_.p_ch_ev[t, n] <= model_.aux_var_greedy[n]
        else:
            return Constraint.Skip

    # Constraints
    model.con_p_ch_limits = Constraint(model.T, model.N,
                                       rule=charging_power_limits)  # For charging/ discharging power limits
    model.con_final_soe = Constraint(model.T, model.N, rule=final_soe)  # For final state of energy
    model.con_soe_update = Constraint(model.T, model.N, rule=soe_update)  # For updating state of energy
    model.con_re_dispatch = Constraint(model.T, rule=re_dispatch)
    model.con_capacity_limitation = Constraint(model.T, rule=capacity_limitation)
    model.con_greedy_dispatch = Constraint(model.T, model.N, rule=greedy_dispatch)

    model.obj_re_dispatch = Objective(
        expr=model.aux_var + model.lambda_ * sum(sum(model.soe_ev[t, n] for n in model.N) for t in model.T),
        sense=maximize)
    model.obj_capacity_limitations = Objective(
        expr=model.aux_var - model.lambda_ * sum(sum(model.soe_ev[t, n] for n in model.N) for t in model.T),
        sense=minimize)
    model.obj_greedy_dispatch = Objective(expr=sum(model.aux_var_greedy[n] for n in model.N) - model.lambda_ * sum(
        sum(model.soe_ev[t, n] for n in model.N) for t in model.T), sense=minimize)

    return model


def activate_all(model__):
    """
    This function activates all the constraints and objective functions in the model.
    :param model__: Concrete model
    :type model__: pyomo.core.base.PyomoModel.ConcreteModel
    :return: None
    """
    model__.con_p_ch_limits.activate()
    model__.con_final_soe.activate()
    model__.con_soe_update.activate()
    model__.con_re_dispatch.activate()
    model__.con_capacity_limitation.activate()
    model__.con_greedy_dispatch.activate()
    model__.obj_re_dispatch.activate()
    model__.obj_capacity_limitations.activate()
    model__.obj_greedy_dispatch.activate()


def model_selection(model_, option):
    """
    This function selects the model to be solved based on the option provided.
    :param model_: Concrete model
    :type model_: pyomo.core.base.PyomoModel.ConcreteModel
    :param option: Parameter to select the model to be solved
    :type option: string: 're-dispatch', 'capacity_limitation', 'greedy_dispatch'
    :return: pyomo.core.base.PyomoModel.ConcreteModel based on the option provided
    :rtype: pyomo.core.base.PyomoModel.ConcreteModel
    """
    if option == 're-dispatch':
        activate_all(model_)
        # Re-dispatching model
        model_.con_capacity_limitation.deactivate()
        model_.con_greedy_dispatch.deactivate()
        model_.obj_capacity_limitations.deactivate()
        model_.obj_greedy_dispatch.deactivate()

    elif option == 'capacity_limitation':
        activate_all(model_)
        # Capacity limitation model
        model_.con_re_dispatch.deactivate()
        model_.con_greedy_dispatch.deactivate()
        model_.obj_re_dispatch.deactivate()
        model_.obj_greedy_dispatch.deactivate()

    elif option == 'greedy_dispatch':
        activate_all(model_)
        # Greedy dispatch model
        model_.con_re_dispatch.deactivate()
        model_.con_capacity_limitation.deactivate()
        model_.obj_re_dispatch.deactivate()
        model_.obj_capacity_limitations.deactivate()



def ev_charging_model_cl(ev_data,
                      dumb_profile,
                      t_step_size=0.25,
                      time_horizon=36 * 4,
                      flex_time_start=17 * 4,
                      flex_time_end=22 * 4, 
                      pmin_tag='',
                      sampled_date='',
                      increment_val = 0,
                      keywords_=None):
    """This function creates a Linear optimisation (concrete) model for smart EV charging based on the following
        strategies:
        * Re-dispatch: Based on the proper selection of constraints and objective function, the model can be used to
                        re-dispatch the EVs to a new charging profile by minimising the aggregated demand based on BAU profile.
                        The BAU profile is based on dumb charging of EVs.
        * Capacity limitation: Based on the proper selection of constraints and objective function, the model can be used to
                            limit the total charging demand of EVs to a certain value.

        * Greedy dispatch: In this mode the algorithms greedily dispatches the EVs so that the demand is minimised
                            between the flex request windows.

    :param keywords_:
    :type keywords_:
    :param ev_data: DataFrame containing EV transaction details. The dataframe must contain
                    the following features:
                    * Information about arrival time (value should be an integer)
                    * Information about departure time (value should be an integer)
                    * Information about total available duration (value should be an integer)
                    * Information about total volume of energyrequired for charging (value should be in kWh)
                    * Information about maximum rate of charging (value should be in kW)
    :type ev_data: pandas.DataFrame
    :param dumb_profile: The aggregate profile for the set of EVs in the ev_data which is generated by the function
        generate_dumb_charging_profile(). The profile is generated by not taking into acount any omptimization.
    :type dumb_profile: numpy.array
    :param t_step_size: The step size of each optimisation period (in hours)
    :type t_step_size: float
    :param time_horizon: The total time horizon for which the system is optimized
    :type time_horizon: int
    :param flex_time_start: The start time (in number of time-steps) from which the flexibility is needed.
    :type flex_time_start: int
    :param flex_time_end: The end time (in number of time-steps) till which the flexibility is needed.
    :type flex_time_end: int
    :param bi_directional_charging_value: Boolean value to indicate if the EVs are bi-directional or not.
    :type bi_directional_charging_value: bool
    :param lambda_value: Sensitivity parameter for the objective function.
    :type lambda_value: float
    :return: This function returns the unsolved concrete model with updated parameters.
    :rtype: pyomo.core.base.PyomoModel.ConcreteModel
    """
    Set_T_length = time_horizon
    Set_N_length = len(ev_data)
    # ---------------------------------- Creating empty model ----------------------------------
    model = ConcreteModel()
    # print('## A concrete optimization model is created for a total %.2f time steps' % Set_T_length)
    # -------------------------------------- Creating Sets --------------------------------------
    model.N = Set(ordered=True, initialize=np.arange(Set_N_length))
    model.T = Set(ordered=True, initialize=np.arange(Set_T_length))

    # ---------------------------------- Creating parameters ----------------------------------
    model.vol_ev = Param(model.N, within=NonNegativeReals, mutable=True, units=u.kWh,
                         doc='Assumed maximum volume of charge in '
                             'kWh that a vehicle can take or is allowed to '
                             'give')
    model.t_a_ev = Param(model.N, within=NonNegativeIntegers, mutable=True, doc='Time step from which a vheicle '
                                                                                'is available')
    model.t_d_ev = Param(model.N, within=NonNegativeIntegers, mutable=True, doc='Time step till which a '
                                                                                'vheicle is still '
                                                                                'available available')
    model.p_max_ev = Param(model.N, within=NonNegativeReals, mutable=True, units=u.kW, doc='Constraint on max power '
                                                                                           'value at which a vheicle can charge it')
    model.p_min_ev = Param(model.N, within=Reals, mutable=True, units=u.kW, doc='Constraint on min '
                                                                                           'power value '
                                                                                           'at which a vheicle can charge '
                                                                                           'it')
    model.base_profile = Param(model.T, mutable=True, doc='Aggregated profile of EVs as per dumb charging')
    model.step_size = Param(initialize=t_step_size, mutable=True, doc='Step size of analysis in hours')
    model.flex_start = Param(initialize=flex_time_start, mutable=True, doc='Initeeger timestep from which'
                                                                           ' flexibility is required')
    model.flex_end = Param(initialize=flex_time_end, mutable=True, doc='Initeger timestep till which'
                                                                       ' flexibility is required')

    

    # ---------------------------------- Creating Variables----------------------------------
    model.p_ch_ev = Var(model.T, model.N, within=Reals, units=u.kW,
                        doc='A NonNegativeReals variable denoting the '
                            'charging power of nth EV at time t')
    model.soe_ev = Var(model.T, model.N, within=NonNegativeReals, units=u.kWh,
                       doc='A NonNegativeReals variable denoting the state '
                           'of charge of nth EV at time t')
    model.aux_var = Var(within=NonNegativeReals, doc='Auxiliary variable used for objective function')


    model.u = Var(model.T, model.N, within=Binary, initialize=1, doc='Binary variable to indicate if the EV is charging or not useful for enforcing current limitation')
    # ---------------------------------- Update parameters ----------------------------------
    update_model_cl(model, ev_data, dumb_profile, flex_time_start, flex_time_end,
                 pmin_tag=pmin_tag,
                 keywords=keywords_, sampled_date=sampled_date, increment=increment_val)

    # ------------------------- Constraint Functions -----------------------------------------
    def charging_power_limits(model_, t, n):
        """
        Constraint rule to enforce limits on the charging power limits
        """
        if t==model_.t_a_ev[n].value:
            return 0, model_.p_ch_ev[t, n], model_.p_max_ev[n]
        
        elif (t > model_.t_a_ev[n].value) & (t < model_.t_d_ev[n].value):
            return model_.p_min_ev[n], model_.p_ch_ev[t, n], model_.p_max_ev[n]
    
        else:
            return model_.p_ch_ev[t, n] == 0
        
    def binary_constraint(model_, t, n):
        """
        This constraint rule makes sure that model.u(t-1,n) >= model.u(t,n) to enforce current limitation
        """
        if (t >= model_.t_a_ev[n].value) & (t < model_.t_d_ev[n].value):
            return model.u[t+1,n] <= model.u[t,n]
        else:
            return Constraint.Skip
          
    def final_soe(model_, t, n):
        """
        This constraint rule makes sure that all  the EVs are charged by the time they depart from the charger.
        """
        if t >= model_.t_d_ev[n].value:
            return model_.soe_ev[t, n] == model_.vol_ev[n]
        else:
            return model_.soe_ev[t, n] <= model_.vol_ev[n]

    def soe_update(model_, t, n):
        """
        This constraint updates the state of energy of the EVs based omn previous state and next step charging power.
        """
        if t <= model_.t_a_ev[n].value:
            return model_.soe_ev[t, n] == 0
        else:
            return model_.soe_ev[t, n] == model_.soe_ev[model_.T.prev(t), n] + \
                model_.step_size * ( model.u[model_.T.prev(t),n]*model_.p_ch_ev[model_.T.prev(t), n])

    def re_dispatch(model_, t):
        """
        Constraint rule for auxiliary variable used in objective function for re-dispatch (eq 1f)

        """
        if (t >= model_.flex_start.value) & (t <= model_.flex_end.value):
            return sum(model.u[t,n]*model_.p_ch_ev[t, n] for n in model_.N) <= model_.base_profile[t] - model_.aux_var
        else:
            return Constraint.Skip


    # Constraints
    model.con_p_ch_limits = Constraint(model.T, model.N,
                                       rule=charging_power_limits)  # For charging/ discharging power limits
    model.con_final_soe = Constraint(model.T, model.N, rule=final_soe)  # For final state of energy
    model.con_soe_update = Constraint(model.T, model.N, rule=soe_update)  # For updating state of energy
    model.con_re_dispatch = Constraint(model.T, rule=re_dispatch)
    model.con_binary = Constraint(model.T, model.N, rule=binary_constraint)

    model.obj_re_dispatch = Objective(expr=model.aux_var, sense=maximize)
   

    return model
